diff --git a/app/build.gradle.kts b/app/build.gradle.kts
index 158e4265f..7113edf79 100644
--- a/app/build.gradle.kts
+++ b/app/build.gradle.kts
@@ -183,10 +183,6 @@ dependencies {
 
     // opening hours parser
     implementation("ch.poole:OpeningHoursParser:0.27.0")
-
-    // measuring distance with AR
-    implementation("com.google.ar:core:1.33.0")
-    implementation("com.google.ar.sceneform:core:1.17.1")
 }
 
 /** Localizations that should be pulled from POEditor */
diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
index bbb984425..e1493d495 100644
--- a/app/src/main/AndroidManifest.xml
+++ b/app/src/main/AndroidManifest.xml
@@ -38,7 +38,6 @@
         android:label="@string/app_name"
         android:theme="@style/AppTheme"
         android:supportsRtl="true">
-        <meta-data android:name="com.google.ar.core" android:value="optional" />
         <activity
             android:windowSoftInputMode="adjustResize"
             android:name="de.westnordost.streetcomplete.screens.MainActivity"
@@ -65,11 +64,6 @@
                 <category android:name="android.intent.category.DEFAULT" />
             </intent-filter>
         </activity>
-        <activity
-            android:name="de.westnordost.streetcomplete.screens.measure.MeasureActivity"
-            android:configChanges="orientation|screenSize"
-            android:screenOrientation="portrait"
-            tools:ignore="LockedOrientationActivity" />
         <activity android:name="de.westnordost.streetcomplete.screens.FragmentContainerActivity" />
         <activity android:name="de.westnordost.streetcomplete.screens.about.AboutActivity" />
         <activity
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/max_height/AddMaxPhysicalHeightForm.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/max_height/AddMaxPhysicalHeightForm.kt
index a95191829..15dacf1eb 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/max_height/AddMaxPhysicalHeightForm.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/max_height/AddMaxPhysicalHeightForm.kt
@@ -8,7 +8,6 @@ import de.westnordost.streetcomplete.R
 import de.westnordost.streetcomplete.databinding.QuestLengthBinding
 import de.westnordost.streetcomplete.quests.AbstractOsmQuestForm
 import de.westnordost.streetcomplete.screens.measure.ArSupportChecker
-import de.westnordost.streetcomplete.screens.measure.TakeMeasurementLauncher
 import de.westnordost.streetcomplete.view.controller.LengthInputViewController
 import kotlinx.coroutines.launch
 import org.koin.android.ext.android.inject
@@ -17,7 +16,6 @@ class AddMaxPhysicalHeightForm : AbstractOsmQuestForm<MaxPhysicalHeightAnswer>()
 
     override val contentLayoutResId = R.layout.quest_length
     private val binding by contentViewBinding(QuestLengthBinding::bind)
-    private val takeMeasurement = TakeMeasurementLauncher(this)
     private val checkArSupport: ArSupportChecker by inject()
     private var isARMeasurement: Boolean = false
     private lateinit var lengthInput: LengthInputViewController
@@ -43,14 +41,6 @@ class AddMaxPhysicalHeightForm : AbstractOsmQuestForm<MaxPhysicalHeightAnswer>()
             checkIsFormComplete()
         }
         binding.measureButton.isGone = !checkArSupport()
-        binding.measureButton.setOnClickListener { lifecycleScope.launch { takeMeasurement() } }
-    }
-
-    private suspend fun takeMeasurement() {
-        val lengthUnit = lengthInput.unit ?: return
-        val length = takeMeasurement(requireContext(), lengthUnit, true) ?: return
-        lengthInput.length = length
-        isARMeasurement = true
     }
 
     override fun isFormComplete(): Boolean = lengthInput.length != null
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/width/AddWidthForm.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/width/AddWidthForm.kt
index f13b195f3..3f307cb70 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/width/AddWidthForm.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/width/AddWidthForm.kt
@@ -9,7 +9,6 @@ import de.westnordost.streetcomplete.databinding.QuestLengthBinding
 import de.westnordost.streetcomplete.osm.ALL_ROADS
 import de.westnordost.streetcomplete.quests.AbstractOsmQuestForm
 import de.westnordost.streetcomplete.screens.measure.ArSupportChecker
-import de.westnordost.streetcomplete.screens.measure.TakeMeasurementLauncher
 import de.westnordost.streetcomplete.view.controller.LengthInputViewController
 import kotlinx.coroutines.launch
 import org.koin.android.ext.android.inject
@@ -18,7 +17,6 @@ class AddWidthForm : AbstractOsmQuestForm<WidthAnswer>() {
 
     override val contentLayoutResId = R.layout.quest_length
     private val binding by contentViewBinding(QuestLengthBinding::bind)
-    private val takeMeasurement = TakeMeasurementLauncher(this)
     private val checkArSupport: ArSupportChecker by inject()
     private var isARMeasurement: Boolean = false
     private lateinit var lengthInput: LengthInputViewController
@@ -49,14 +47,6 @@ class AddWidthForm : AbstractOsmQuestForm<WidthAnswer>() {
             checkIsFormComplete()
         }
         binding.measureButton.isGone = !checkArSupport()
-        binding.measureButton.setOnClickListener { lifecycleScope.launch { takeMeasurement() } }
-    }
-
-    private suspend fun takeMeasurement() {
-        val lengthUnit = lengthInput.unit ?: return
-        val length = takeMeasurement(requireContext(), lengthUnit, false) ?: return
-        lengthInput.length = length
-        isARMeasurement = true
     }
 
     override fun onClickOk() {
diff --git a/app/src/main/java/de/westnordost/streetcomplete/screens/measure/ArCoreSessionCreator.kt b/app/src/main/java/de/westnordost/streetcomplete/screens/measure/ArCoreSessionCreator.kt
deleted file mode 100644
index 991e0cf88..000000000
--- a/app/src/main/java/de/westnordost/streetcomplete/screens/measure/ArCoreSessionCreator.kt
+++ /dev/null
@@ -1,156 +0,0 @@
-package de.westnordost.streetcomplete.screens.measure
-
-import android.Manifest
-import android.app.ActivityManager
-import android.os.Build
-import androidx.activity.result.contract.ActivityResultContracts
-import androidx.appcompat.app.AppCompatActivity
-import androidx.core.app.ActivityCompat
-import androidx.core.content.getSystemService
-import androidx.lifecycle.DefaultLifecycleObserver
-import androidx.lifecycle.LifecycleOwner
-import com.google.ar.core.ArCoreApk
-import com.google.ar.core.ArCoreApk.Availability.UNKNOWN_CHECKING
-import com.google.ar.core.ArCoreApk.Availability.UNKNOWN_TIMED_OUT
-import com.google.ar.core.ArCoreApk.Availability.UNSUPPORTED_DEVICE_NOT_CAPABLE
-import com.google.ar.core.Session
-import com.google.ar.core.exceptions.UnavailableDeviceNotCompatibleException
-import com.google.ar.core.exceptions.UnavailableException
-import com.google.ar.core.exceptions.UnavailableSdkTooOldException
-import com.google.ar.core.exceptions.UnavailableUserDeclinedInstallationException
-import de.westnordost.streetcomplete.screens.measure.ArNotAvailableReason.ANDROID_SDK_VERSION_TOO_OLD
-import de.westnordost.streetcomplete.screens.measure.ArNotAvailableReason.AR_CORE_APK_NOT_INSTALLED_OR_TOO_OLD
-import de.westnordost.streetcomplete.screens.measure.ArNotAvailableReason.AR_CORE_SDK_TOO_OLD
-import de.westnordost.streetcomplete.screens.measure.ArNotAvailableReason.DEVICE_COMPATIBILITY_CHECK_FAILURE
-import de.westnordost.streetcomplete.screens.measure.ArNotAvailableReason.DEVICE_COMPATIBILITY_CHECK_TIMED_OUT
-import de.westnordost.streetcomplete.screens.measure.ArNotAvailableReason.DEVICE_NOT_COMPATIBLE
-import de.westnordost.streetcomplete.screens.measure.ArNotAvailableReason.NO_CAMERA_PERMISSION
-import de.westnordost.streetcomplete.util.ActivityForResultLauncher
-import de.westnordost.streetcomplete.util.ktx.hasCameraPermission
-import kotlin.coroutines.resume
-import kotlin.coroutines.resumeWithException
-import kotlin.coroutines.suspendCoroutine
-
-/** Creates an ARCore session and ensures that everything is set up to be able to use AR:
- *  - Checks the Android SDK version and OpenGL ES version
- *  - Checks if this device is compatible with AR
- *  - Checks if ARCore has been installed, is up-to-date and if not, requests the user to do this
- *  - Checks for camera permission and if no permission has been granted yet, (re)requests it
- *  - Checks if the ARCore SDK used is still compatible with the current ARCore installation
- */
-class ArCoreSessionCreator(
-    private val activity: AppCompatActivity,
-    private val askUserToAcknowledgeCameraPermissionRationale: suspend () -> Boolean,
-    private val features: Set<Session.Feature> = setOf()
-) {
-    private val requestPermission = ActivityForResultLauncher(activity, ActivityResultContracts.RequestPermission())
-
-    /** Returns an ARCore session (after some back and forth with the user) or a reason why it can't
-     *  be created */
-    suspend operator fun invoke(): Result {
-
-        /* extra requirements for Sceneform: min Android SDK and OpenGL ES 3.1*/
-        if (!hasSufficientAndroidSdkVersion()) {
-            return Failure(ANDROID_SDK_VERSION_TOO_OLD)
-        }
-
-        if (!hasSufficientOpenGlEsVersion()) {
-            return Failure(DEVICE_NOT_COMPATIBLE)
-        }
-
-        val availability = getArCoreAvailability()
-        if (!availability.isSupported) {
-            return when (availability) {
-                UNKNOWN_CHECKING, UNKNOWN_TIMED_OUT -> Failure(DEVICE_COMPATIBILITY_CHECK_TIMED_OUT)
-                UNSUPPORTED_DEVICE_NOT_CAPABLE ->      Failure(DEVICE_NOT_COMPATIBLE)
-                else ->                                Failure(DEVICE_COMPATIBILITY_CHECK_FAILURE)
-            }
-        }
-
-        val installStatus = requestArCoreInstallation()
-        if (installStatus == ArCoreApk.InstallStatus.INSTALL_REQUESTED) {
-            try {
-                awaitArCoreInstallation()
-            } catch (e: UnavailableDeviceNotCompatibleException) {
-                return Failure(DEVICE_NOT_COMPATIBLE)
-            } catch (e: UnavailableUserDeclinedInstallationException) {
-                return Failure(AR_CORE_APK_NOT_INSTALLED_OR_TOO_OLD)
-            }
-        }
-
-        if (!activity.hasCameraPermission) {
-            if (!requestCameraPermission()) {
-                return Failure(NO_CAMERA_PERMISSION)
-            }
-        }
-
-        val session: Session
-        try {
-            session = Session(activity, features)
-        } catch (e: UnavailableSdkTooOldException) {
-            return Failure(AR_CORE_SDK_TOO_OLD)
-        } catch (e: UnavailableDeviceNotCompatibleException) {
-            return Failure(DEVICE_NOT_COMPATIBLE)
-        }
-
-        return Success(session)
-    }
-
-    private fun hasSufficientAndroidSdkVersion(): Boolean =
-        Build.VERSION.SDK_INT >= Build.VERSION_CODES.N
-
-    private fun hasSufficientOpenGlEsVersion(): Boolean =
-        activity.getSystemService<ActivityManager>()!!.deviceConfigurationInfo.glEsVersion.toDouble() >= 3.1
-
-    private suspend fun getArCoreAvailability(): ArCoreApk.Availability =
-        ArCoreApk.getInstance().getAvailability(activity)
-
-    private fun requestArCoreInstallation(): ArCoreApk.InstallStatus =
-        ArCoreApk.getInstance().requestInstall(activity, true)
-
-    private suspend fun awaitArCoreInstallation() {
-        suspendCoroutine {
-            val observer = object : DefaultLifecycleObserver {
-                override fun onResume(lifecycleOwner: LifecycleOwner) {
-                    try {
-                        /* contrary to what the documentation claims, this method can actually
-                           return INSTALL_REQUESTED even if the userRequestedInstall parameter is
-                           false. So, we can only continue when it returns INSTALLED */
-                        val installStatus = ArCoreApk.getInstance().requestInstall(activity, false)
-                        if (installStatus == ArCoreApk.InstallStatus.INSTALLED) {
-                            activity.lifecycle.removeObserver(this)
-                            it.resume(Unit)
-                        }
-                    } catch (e: UnavailableException) {
-                        activity.lifecycle.removeObserver(this)
-                        it.resumeWithException(e)
-                    }
-                }
-            }
-            activity.lifecycle.addObserver(observer)
-        }
-    }
-
-    private suspend fun requestCameraPermission(): Boolean {
-        if (ActivityCompat.shouldShowRequestPermissionRationale(activity, Manifest.permission.CAMERA)) {
-            if (!askUserToAcknowledgeCameraPermissionRationale()) {
-                return false
-            }
-        }
-        return requestPermission(Manifest.permission.CAMERA)
-    }
-
-    sealed class Result
-    data class Success(val session: Session) : Result()
-    data class Failure(val reason: ArNotAvailableReason) : Result()
-}
-
-enum class ArNotAvailableReason {
-    ANDROID_SDK_VERSION_TOO_OLD,
-    DEVICE_COMPATIBILITY_CHECK_TIMED_OUT,
-    DEVICE_COMPATIBILITY_CHECK_FAILURE,
-    DEVICE_NOT_COMPATIBLE,
-    NO_CAMERA_PERMISSION,
-    AR_CORE_APK_NOT_INSTALLED_OR_TOO_OLD,
-    AR_CORE_SDK_TOO_OLD
-}
diff --git a/app/src/main/java/de/westnordost/streetcomplete/screens/measure/ArCoreXt.kt b/app/src/main/java/de/westnordost/streetcomplete/screens/measure/ArCoreXt.kt
deleted file mode 100644
index 4b6b40a89..000000000
--- a/app/src/main/java/de/westnordost/streetcomplete/screens/measure/ArCoreXt.kt
+++ /dev/null
@@ -1,53 +0,0 @@
-package de.westnordost.streetcomplete.screens.measure
-
-import android.content.Context
-import com.google.ar.core.ArCoreApk
-import com.google.ar.core.Frame
-import com.google.ar.core.Plane
-import com.google.ar.core.Pose
-import com.google.ar.core.TrackingFailureReason
-import com.google.ar.core.TrackingFailureReason.BAD_STATE
-import com.google.ar.core.TrackingFailureReason.CAMERA_UNAVAILABLE
-import com.google.ar.core.TrackingFailureReason.EXCESSIVE_MOTION
-import com.google.ar.core.TrackingFailureReason.INSUFFICIENT_FEATURES
-import com.google.ar.core.TrackingFailureReason.INSUFFICIENT_LIGHT
-import com.google.ar.core.TrackingFailureReason.NONE
-import com.google.ar.core.TrackingState.TRACKING
-import com.google.ar.sceneform.math.Quaternion
-import com.google.ar.sceneform.math.Vector3
-import de.westnordost.streetcomplete.R
-import kotlinx.coroutines.delay
-import kotlin.math.abs
-import kotlin.math.atan2
-
-fun Frame.hasFoundPlane(): Boolean =
-    getUpdatedTrackables(Plane::class.java).any { it.trackingState == TRACKING }
-
-suspend fun ArCoreApk.getAvailability(context: Context): ArCoreApk.Availability {
-    var result = checkAvailability(context)
-    // only check again ONCE because of https://github.com/google-ar/arcore-android-sdk/issues/343
-    if (result.isTransient) {
-        delay(200)
-        result = checkAvailability(context)
-    }
-    return result
-}
-
-val TrackingFailureReason.messageResId: Int? get() = when (this) {
-    NONE -> null
-    BAD_STATE -> R.string.ar_core_tracking_error_bad_state
-    INSUFFICIENT_LIGHT -> R.string.ar_core_tracking_error_insufficient_light
-    EXCESSIVE_MOTION -> R.string.ar_core_tracking_error_excessive_motion
-    INSUFFICIENT_FEATURES -> R.string.ar_core_tracking_error_insufficient_features
-    CAMERA_UNAVAILABLE -> R.string.ar_core_tracking_error_camera_unavailable
-}
-
-val Pose.position: Vector3 get() = Vector3(tx(), ty(), tz())
-val Pose.pitch: Float get() {
-    val (x, y, z, w) = rotationQuaternion
-    return if (0.5 - abs(x * y + z * w) < 0.001) 0f
-           else atan2(2 * (x * w - y * z), -x * x + y * y - z * z + w * w)
-}
-
-fun Quaternion.difference(other: Quaternion): Quaternion =
-    Quaternion.multiply(this, other.inverted())
diff --git a/app/src/main/java/de/westnordost/streetcomplete/screens/measure/ArSupportChecker.kt b/app/src/main/java/de/westnordost/streetcomplete/screens/measure/ArSupportChecker.kt
index 270d06763..07f4b61bd 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/screens/measure/ArSupportChecker.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/screens/measure/ArSupportChecker.kt
@@ -4,13 +4,7 @@ import android.app.ActivityManager
 import android.content.Context
 import android.os.Build
 import androidx.core.content.getSystemService
-import com.google.ar.core.ArCoreApk
 
 class ArSupportChecker(private val context: Context) {
-    operator fun invoke(): Boolean =
-        // extra requirements for Sceneform: min Android SDK and OpenGL ES 3.1
-        Build.VERSION.SDK_INT >= Build.VERSION_CODES.N
-        && context.getSystemService<ActivityManager>()!!.deviceConfigurationInfo.glEsVersion.toDouble() >= 3.1
-        // otherwise, ask ArCore
-        && ArCoreApk.getInstance().checkAvailability(context).isSupported
+    operator fun invoke(): Boolean = false
 }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/screens/measure/MeasureActivity.kt b/app/src/main/java/de/westnordost/streetcomplete/screens/measure/MeasureActivity.kt
deleted file mode 100644
index 6106b7810..000000000
--- a/app/src/main/java/de/westnordost/streetcomplete/screens/measure/MeasureActivity.kt
+++ /dev/null
@@ -1,515 +0,0 @@
-package de.westnordost.streetcomplete.screens.measure
-
-import android.content.Context
-import android.content.Intent
-import android.os.Build
-import android.os.Bundle
-import android.util.Log
-import android.view.HapticFeedbackConstants.VIRTUAL_KEY
-import android.view.ViewGroup.LayoutParams.MATCH_PARENT
-import android.view.WindowManager
-import androidx.annotation.RequiresApi
-import androidx.appcompat.app.AlertDialog
-import androidx.appcompat.app.AppCompatActivity
-import androidx.core.view.isGone
-import androidx.core.view.isInvisible
-import androidx.lifecycle.lifecycleScope
-import com.google.ar.core.Config
-import com.google.ar.core.Frame
-import com.google.ar.core.HitResult
-import com.google.ar.core.Plane
-import com.google.ar.core.Pose
-import com.google.ar.core.Session
-import com.google.ar.core.TrackingState.TRACKING
-import com.google.ar.core.exceptions.CameraNotAvailableException
-import com.google.ar.sceneform.AnchorNode
-import com.google.ar.sceneform.ArSceneView
-import com.google.ar.sceneform.FrameTime
-import com.google.ar.sceneform.Node
-import com.google.ar.sceneform.Scene
-import com.google.ar.sceneform.math.Quaternion
-import com.google.ar.sceneform.math.Vector3
-import com.google.ar.sceneform.rendering.Color
-import com.google.ar.sceneform.rendering.MaterialFactory
-import com.google.ar.sceneform.rendering.Renderable
-import com.google.ar.sceneform.rendering.ShapeFactory
-import com.google.ar.sceneform.rendering.ViewRenderable
-import de.westnordost.streetcomplete.R
-import de.westnordost.streetcomplete.databinding.ActivityMeasureBinding
-import de.westnordost.streetcomplete.screens.measure.MeasureActivity.Companion.createIntent
-import de.westnordost.streetcomplete.util.ktx.toast
-import de.westnordost.streetcomplete.util.math.normalizeRadians
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.GlobalScope
-import kotlinx.coroutines.future.await
-import kotlinx.coroutines.launch
-import kotlinx.coroutines.suspendCancellableCoroutine
-import kotlinx.serialization.decodeFromString
-import kotlinx.serialization.encodeToString
-import kotlinx.serialization.json.Json
-import kotlin.coroutines.resume
-import kotlin.math.PI
-import kotlin.math.abs
-import kotlin.math.max
-import kotlin.math.pow
-import kotlin.math.sqrt
-import kotlin.math.tan
-
-/** Activity to measure distances. Can be started as activity for result, see [createIntent] */
-class MeasureActivity : AppCompatActivity(), Scene.OnUpdateListener {
-
-    private val createArCoreSession = ArCoreSessionCreator(this, ::askUserToAcknowledgeCameraPermissionRationale)
-
-    private lateinit var binding: ActivityMeasureBinding
-    private var arSceneView: ArSceneView? = null
-
-    private var cursorRenderable: Renderable? = null
-    private var pointRenderable: Renderable? = null
-    private var lineRenderable: Renderable? = null
-
-    private var lineNode: Node? = null
-    private var firstNode: AnchorNode? = null
-    private var secondNode: Node? = null
-    private var cursorNode: AnchorNode? = null
-
-    private var measureVertical: Boolean = false
-    private var displayUnit: MeasureDisplayUnit = MeasureDisplayUnitMeter(2)
-    private var requestResult: Boolean = false
-
-    private enum class MeasureState { READY, MEASURING, DONE }
-    private var measureState: MeasureState = MeasureState.READY
-
-    private var distance: Float = 0f
-
-    /* ---------------------------------------- Lifecycle --------------------------------------- */
-
-    override fun onCreate(savedInstanceState: Bundle?) {
-        super.onCreate(savedInstanceState)
-
-        // no turning off screen automatically while measuring, also no colored navbar
-        window.addFlags(
-            WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON or
-            WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION or
-            WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS
-        )
-        readIntent()
-        distance = 0f
-
-        try {
-            binding = ActivityMeasureBinding.inflate(layoutInflater)
-        } catch (e: Exception) {
-            /* layout inflation may fail for the ArSceneView for some old devices that don't support
-               AR anyway. So we can just exit */
-            finish()
-            return
-        }
-
-        setContentView(binding.root)
-        binding.startOverButton.setOnClickListener { clearMeasuring() }
-        binding.acceptButton.setOnClickListener { returnMeasuringResult() }
-
-        lifecycleScope.launch {
-            initializeSession()
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
-                initRenderables()
-            }
-        }
-    }
-
-    override fun onResume() {
-        super.onResume()
-        if (arSceneView != null) {
-            try {
-                arSceneView?.resume()
-                binding.handMotionView.isGone = false
-                binding.trackingMessageTextView.isGone = true
-            } catch (e: CameraNotAvailableException) {
-                // without camera, we can't do anything, might as well quit
-                finish()
-            }
-        }
-    }
-
-    override fun onPause() {
-        super.onPause()
-        arSceneView?.pause()
-    }
-
-    override fun onDestroy() {
-        super.onDestroy()
-        arSceneView?.pause()
-        arSceneView?.destroy()
-        // closing can take several seconds, should be done one background thread that outlives this activity
-        GlobalScope.launch(Dispatchers.Default) {
-            arSceneView?.session?.close()
-        }
-    }
-
-    private fun readIntent() {
-        measureVertical = intent.getBooleanExtra(PARAM_MEASURE_VERTICAL, measureVertical)
-        displayUnit = intent.getStringExtra(PARAM_DISPLAY_UNIT)?.let { Json.decodeFromString(it) }
-            ?: MeasureDisplayUnitMeter(2)
-        requestResult = intent.getBooleanExtra(PARAM_REQUEST_RESULT, false)
-    }
-
-    /* --------------------------------- Scene.OnUpdateListener --------------------------------- */
-
-    override fun onUpdate(frameTime: FrameTime) {
-        val frame = arSceneView?.arFrame ?: return
-
-        if (frame.hasFoundPlane()) {
-            binding.handMotionView.isGone = true
-        }
-
-        setTrackingMessage(frame.camera.trackingFailureReason.messageResId)
-
-        if (frame.camera.trackingState == TRACKING) {
-            if (measureVertical) {
-                if (measureState == MeasureState.READY) {
-                    hitPlaneAndUpdateCursor(frame)
-                } else if (measureState == MeasureState.MEASURING) {
-                    updateVerticalMeasuring(frame.camera.displayOrientedPose)
-                }
-            } else {
-                hitPlaneAndUpdateCursor(frame)
-            }
-        }
-    }
-
-    private fun hitPlaneAndUpdateCursor(frame: Frame) {
-        val centerX = binding.arSceneViewContainer.width / 2f
-        val centerY = binding.arSceneViewContainer.height / 2f
-        val hitResults = frame.hitTest(centerX, centerY).filter {
-            (it.trackable as? Plane)?.isPoseInPolygon(it.hitPose) == true
-        }
-        val firstNode = firstNode
-        val hitResult = if (firstNode == null) {
-            hitResults.firstOrNull()
-        } else {
-            /* after first node is placed on the plane, only accept hits with (other) planes
-               that are more or less on the same height */
-            hitResults.find { abs(it.hitPose.ty() - firstNode.worldPosition.y) < 0.1 }
-        }
-
-        if (hitResult != null) {
-            updateCursor(hitResult)
-            setTrackingMessage(
-                if (measureState == MeasureState.READY) R.string.ar_core_tracking_hint_tap_to_measure else null
-            )
-        } else {
-            /* when no plane can be found at the cursor position and the camera angle is
-               shallow enough, display a hint that user should cross street
-             */
-            val cursorDistanceFromCamera = cursorNode?.worldPosition?.let {
-                Vector3.subtract(frame.camera.pose.position, it).length()
-            } ?: 0f
-
-            setTrackingMessage(
-                if (cursorDistanceFromCamera > 3f) R.string.ar_core_tracking_error_no_plane_hit else null
-            )
-        }
-    }
-
-    private fun setTrackingMessage(messageResId: Int?) {
-        binding.trackingMessageTextView.isGone = messageResId == null
-        messageResId?.let { binding.trackingMessageTextView.setText(messageResId) }
-    }
-
-    /* ------------------------------------------ Session --------------------------------------- */
-
-    private suspend fun initializeSession() {
-        val result = createArCoreSession()
-        if (result is ArCoreSessionCreator.Success) {
-            val session = result.session
-            configureSession(session)
-            addArSceneView(session)
-        } else if (result is ArCoreSessionCreator.Failure) {
-            val reason = result.reason
-            if (reason == ArNotAvailableReason.AR_CORE_SDK_TOO_OLD) {
-                toast(R.string.ar_core_error_sdk_too_old)
-            } else if (reason == ArNotAvailableReason.NO_CAMERA_PERMISSION) {
-                toast(R.string.no_camera_permission_toast)
-            }
-            // otherwise nothing we can do here...
-            finish()
-        }
-    }
-
-    private fun configureSession(session: Session) {
-        val config = Config(session)
-
-        config.updateMode = Config.UpdateMode.LATEST_CAMERA_IMAGE // necessary for Sceneform
-        config.planeFindingMode = Config.PlaneFindingMode.HORIZONTAL
-        // disabling unused features should make processing faster
-        config.depthMode = Config.DepthMode.DISABLED
-        config.cloudAnchorMode = Config.CloudAnchorMode.DISABLED
-        config.instantPlacementMode = Config.InstantPlacementMode.DISABLED
-        config.lightEstimationMode = Config.LightEstimationMode.DISABLED
-
-        session.configure(config)
-    }
-
-    private fun addArSceneView(session: Session) {
-        val arSceneView = ArSceneView(this)
-        arSceneView.planeRenderer.isEnabled = false
-        binding.arSceneViewContainer.addView(arSceneView, MATCH_PARENT, MATCH_PARENT)
-        arSceneView.setupSession(session)
-        arSceneView.scene.addOnUpdateListener(this)
-        arSceneView.setOnClickListener { onTapPlane() }
-        this.arSceneView = arSceneView
-    }
-
-    /* ---------------------------------------- Measuring --------------------------------------- */
-
-    private fun onTapPlane() {
-        when (measureState) {
-            MeasureState.READY -> {
-                startMeasuring()
-            }
-            MeasureState.MEASURING -> {
-                measuringDone()
-            }
-            MeasureState.DONE -> {
-                /* different behavior: When caller requests result, tapping again doesn't clear the
-                 * result, instead the user needs to tap on the "start over" button, like when
-                 * taking a picture with the camera */
-                if (!requestResult) clearMeasuring() else continueMeasuring()
-            }
-        }
-    }
-
-    @RequiresApi(Build.VERSION_CODES.N)
-    private suspend fun initRenderables() {
-        // takes about half a second on a high-end device(!)
-        val attributes = obtainStyledAttributes(intArrayOf(android.R.attr.colorAccent))
-        val argb = attributes.getColor(0, 0)
-        attributes.recycle()
-        val materialBlue = MaterialFactory.makeOpaqueWithColor(this, Color(argb)).await()
-        cursorRenderable = ViewRenderable.builder().setView(this, R.layout.view_ar_cursor).build().await()
-        pointRenderable = ShapeFactory.makeCylinder(0.03f, 0.005f, Vector3.zero(), materialBlue)
-        lineRenderable = ShapeFactory.makeCube(Vector3(0.02f, 0.005f, 1f), Vector3.zero(), materialBlue)
-        listOfNotNull(cursorRenderable, pointRenderable, lineRenderable).forEach {
-            it.isShadowCaster = false
-            it.isShadowReceiver = false
-        }
-        // in case they have been initialized already, (re)set renderables...
-        cursorNode?.renderable = cursorRenderable
-        firstNode?.renderable = pointRenderable
-        secondNode?.renderable = pointRenderable
-        lineNode?.renderable = lineRenderable
-    }
-
-    private fun startMeasuring() {
-        val anchor = cursorNode?.anchor ?: return
-        measureState = MeasureState.MEASURING
-        binding.arSceneViewContainer.performHapticFeedback(VIRTUAL_KEY)
-        firstNode = AnchorNode().apply {
-            renderable = pointRenderable
-            setParent(arSceneView!!.scene)
-            setAnchor(anchor)
-        }
-
-        if (measureVertical) {
-            secondNode = Node()
-            cursorNode?.isEnabled = false
-        } else {
-            secondNode = AnchorNode().apply { setAnchor(anchor) }
-        }
-        secondNode?.apply {
-            renderable = pointRenderable
-            setParent(arSceneView!!.scene)
-        }
-    }
-
-    private fun measuringDone() {
-        binding.arSceneViewContainer.performHapticFeedback(VIRTUAL_KEY)
-        if (requestResult) binding.acceptResultContainer.isGone = false
-        measureState = MeasureState.DONE
-    }
-
-    private fun continueMeasuring() {
-        binding.arSceneViewContainer.performHapticFeedback(VIRTUAL_KEY)
-        if (requestResult) binding.acceptResultContainer.isGone = true
-        measureState = MeasureState.MEASURING
-    }
-
-    private fun clearMeasuring() {
-        measureState = MeasureState.READY
-        binding.arSceneViewContainer.performHapticFeedback(VIRTUAL_KEY)
-        binding.measurementSpeechBubble.isInvisible = true
-        binding.acceptResultContainer.isGone = true
-        distance = 0f
-        cursorNode?.isEnabled = true
-        firstNode?.anchor?.detach()
-        firstNode?.setParent(null)
-        firstNode = null
-        (secondNode as? AnchorNode)?.anchor?.detach()
-        secondNode?.setParent(null)
-        secondNode = null
-        lineNode?.setParent(null)
-        lineNode = null
-    }
-
-    private fun returnMeasuringResult() {
-        val resultIntent = Intent(RESULT_ACTION)
-        when (val displayUnit = displayUnit) {
-            is MeasureDisplayUnitFeetInch -> {
-                val (feet, inches) = displayUnit.getRounded(distance)
-                resultIntent.putExtra(RESULT_MEASURE_FEET, feet)
-                resultIntent.putExtra(RESULT_MEASURE_INCHES, inches)
-            }
-            is MeasureDisplayUnitMeter -> {
-                resultIntent.putExtra(RESULT_MEASURE_METERS, displayUnit.getRounded(distance))
-            }
-        }
-        setResult(RESULT_OK, resultIntent)
-        finish()
-    }
-
-    private fun updateCursor(hitResult: HitResult) {
-        // release previous anchor only if it is not used by any other node
-        val anchor = cursorNode?.anchor
-        if (anchor != null && anchor != firstNode?.anchor && anchor != (secondNode as? AnchorNode)?.anchor) {
-            anchor.detach()
-        }
-
-        try {
-            val newAnchor = hitResult.createAnchor()
-            val cursorNode = getCursorNode()
-            cursorNode.anchor = newAnchor
-
-            if (measureState == MeasureState.MEASURING) {
-                (secondNode as? AnchorNode)?.anchor = newAnchor
-                updateDistance()
-            }
-        } catch (e: Exception) {
-            Log.e("MeasureActivity", "Error", e)
-        }
-    }
-
-    private fun updateVerticalMeasuring(cameraPose: Pose) {
-        val cameraPos = cameraPose.position
-        val nodePos = firstNode!!.worldPosition
-
-        val cameraToNodeHeightDifference = cameraPos.y - nodePos.y
-        val cameraToNodeDistanceOnPlane = sqrt((cameraPos.x - nodePos.x).pow(2) + (cameraPos.z - nodePos.z).pow(2))
-        val cameraAngle = cameraPose.pitch
-
-        val normalizedCameraAngle = normalizeRadians(cameraAngle.toDouble(), -PI)
-        val pi2 = PI / 2
-        if (normalizedCameraAngle < -pi2 * 2 / 3 || normalizedCameraAngle > +pi2 * 1 / 2) {
-            setTrackingMessage(R.string.ar_core_tracking_error_too_steep_angle)
-            return
-        } else {
-            setTrackingMessage(null)
-        }
-
-        // don't allow negative heights (into the ground)
-        val height = max(0f, cameraToNodeHeightDifference + cameraToNodeDistanceOnPlane * tan(cameraAngle))
-
-        val pos = Vector3.add(nodePos, Vector3(0f, height, 0f))
-        secondNode?.worldPosition = pos
-
-        updateDistance()
-    }
-
-    private fun updateDistance() {
-        val pos1 = firstNode?.worldPosition
-        val pos2 = secondNode?.worldPosition
-        val up = firstNode?.up
-        val hasMeasurement = pos1 != null && pos2 != null && up != null
-
-        binding.measurementSpeechBubble.isInvisible = !hasMeasurement
-        if (!hasMeasurement) return
-
-        val difference = Vector3.subtract(pos1, pos2)
-        distance = difference.length()
-        binding.measurementTextView.text = displayUnit.format(distance)
-
-        val line = getLineNode()
-        line.worldPosition = Vector3.add(pos1, pos2).scaled(.5f)
-        line.worldRotation = Quaternion.lookRotation(difference, up)
-        line.localScale = Vector3(1f, 1f, distance)
-    }
-
-    private fun getCursorNode(): AnchorNode {
-        var node = cursorNode
-        if (node == null) {
-            node = AnchorNode().apply {
-                renderable = cursorRenderable
-                setParent(arSceneView!!.scene)
-            }
-            cursorNode = node
-        }
-        return node
-    }
-
-    private fun getLineNode(): Node {
-        var node = lineNode
-        if (node == null) {
-            node = Node().apply {
-                renderable = lineRenderable
-                setParent(arSceneView!!.scene)
-            }
-            lineNode = node
-        }
-        return node
-    }
-
-    /* ----------------------------------- Permission request ----------------------------------- */
-
-    /** Show dialog that explains why the camera permission is necessary. Returns whether the user
-     *  acknowledged the rationale. */
-    private suspend fun askUserToAcknowledgeCameraPermissionRationale(): Boolean =
-        suspendCancellableCoroutine { cont ->
-            val dlg = AlertDialog.Builder(this)
-                .setTitle(R.string.no_camera_permission_warning_title)
-                .setMessage(R.string.no_camera_permission_warning)
-                .setPositiveButton(android.R.string.ok) { _, _ -> cont.resume(true) }
-                .setNegativeButton(android.R.string.cancel) { _, _ -> cont.resume(false) }
-                .setOnCancelListener { cont.resume(false) }
-                .create()
-            cont.invokeOnCancellation { dlg.cancel() }
-            dlg.show()
-        }
-
-    /* ----------------------------------------- Intent ----------------------------------------- */
-
-    companion object {
-        private const val PARAM_MEASURE_VERTICAL = "measure_vertical"
-        private const val PARAM_DISPLAY_UNIT = "display_unit"
-        private const val PARAM_REQUEST_RESULT = "request_result"
-
-        /** The action to identify a result */
-        const val RESULT_ACTION = "de.westnordost.streetcomplete.screens.measure.RESULT_ACTION"
-
-        /** The result as displayed to the user, set if display unit was meters. Float. */
-        const val RESULT_MEASURE_METERS = "measure_result_meters"
-
-        /** The result as displayed to the user, set if display unit was feet+inches. Int. */
-        const val RESULT_MEASURE_FEET = "measure_result_feet"
-
-        /** The result as displayed to the user, set if display unit was feet+inches. Int. */
-        const val RESULT_MEASURE_INCHES = "measure_result_inches"
-
-        /** Create the intent for starting this activity, with optional parameters:
-         * @param vertical whether to measure vertical distances
-         * @param unit specifies which unit (meters or foot/inch) should be used for display and
-         *             with which precision the measure should be shown (where to round to).
-         * @param requestResult whether this activity should return a result. If yes, the activity
-         *                      will return the raw measure result (not rounded) in
-         *                      RESULT_MEASURE_IN_METERS when the user confirmed it. */
-        fun createIntent(
-            context: Context,
-            vertical: Boolean? = null,
-            unit: MeasureDisplayUnit? = null,
-            requestResult: Boolean? = null,
-        ): Intent {
-            val intent = Intent(context, MeasureActivity::class.java)
-            vertical?.let { intent.putExtra(PARAM_MEASURE_VERTICAL, it) }
-            unit?.let { intent.putExtra(PARAM_DISPLAY_UNIT, Json.encodeToString(it)) }
-            requestResult?.let { intent.putExtra(PARAM_REQUEST_RESULT, it) }
-            return intent
-        }
-    }
-}
diff --git a/app/src/main/java/de/westnordost/streetcomplete/screens/measure/TakeMeasurementLauncher.kt b/app/src/main/java/de/westnordost/streetcomplete/screens/measure/TakeMeasurementLauncher.kt
deleted file mode 100644
index 7514c11f4..000000000
--- a/app/src/main/java/de/westnordost/streetcomplete/screens/measure/TakeMeasurementLauncher.kt
+++ /dev/null
@@ -1,49 +0,0 @@
-package de.westnordost.streetcomplete.screens.measure
-
-import android.app.Activity
-import android.content.Context
-import androidx.activity.result.ActivityResultCaller
-import androidx.activity.result.contract.ActivityResultContracts
-import de.westnordost.streetcomplete.data.meta.LengthUnit
-import de.westnordost.streetcomplete.osm.Length
-import de.westnordost.streetcomplete.osm.LengthInFeetAndInches
-import de.westnordost.streetcomplete.osm.LengthInMeters
-import de.westnordost.streetcomplete.screens.measure.MeasureActivity.Companion.RESULT_MEASURE_FEET
-import de.westnordost.streetcomplete.screens.measure.MeasureActivity.Companion.RESULT_MEASURE_INCHES
-import de.westnordost.streetcomplete.screens.measure.MeasureActivity.Companion.RESULT_MEASURE_METERS
-import de.westnordost.streetcomplete.util.ActivityForResultLauncher
-
-/** Launches the MeasureActivity and returns its result */
-class TakeMeasurementLauncher(caller: ActivityResultCaller) {
-
-    private val activityForResultLauncher = ActivityForResultLauncher(caller, ActivityResultContracts.StartActivityForResult())
-
-    /** Returns the measured Length or null, displayed at and rounded to a precision of 10cm / 4in */
-    suspend operator fun invoke(
-        context: Context,
-        lengthUnit: LengthUnit,
-        measureVertical: Boolean? = null
-    ): Length? {
-        val unit = when (lengthUnit) {
-            LengthUnit.METER -> MeasureDisplayUnitMeter(10)
-            LengthUnit.FOOT_AND_INCH -> MeasureDisplayUnitFeetInch(4)
-        }
-        val result = activityForResultLauncher(MeasureActivity.createIntent(context, measureVertical, unit, true))
-        if (result.resultCode != Activity.RESULT_OK) return null
-
-        val meters = result.data?.getFloatExtra(RESULT_MEASURE_METERS, -1f)?.takeIf { it != -1f }
-        if (meters != null) {
-            /* e.g. `1.7f.toDouble()` will return `1.7000000476837158` but we really want the
-               result as it is printed, this is why we first convert to string and then back to
-               double :-/ */
-            return LengthInMeters(meters.toString().toDouble())
-        }
-
-        val feet = result.data?.getIntExtra(RESULT_MEASURE_FEET, -1)?.takeIf { it != -1 }
-        val inches = result.data?.getIntExtra(RESULT_MEASURE_INCHES, -1)?.takeIf { it != -1 }
-        if (feet != null && inches != null) {
-            return LengthInFeetAndInches(feet, inches)
-        }
-        return null
-    }
-}
diff --git a/app/src/main/java/de/westnordost/streetcomplete/screens/settings/SettingsFragment.kt b/app/src/main/java/de/westnordost/streetcomplete/screens/settings/SettingsFragment.kt
index 650563907..6bdfca46b 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/screens/settings/SettingsFragment.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/screens/settings/SettingsFragment.kt
@@ -29,7 +29,6 @@ import de.westnordost.streetcomplete.data.visiblequests.QuestPresetsSource
 import de.westnordost.streetcomplete.data.visiblequests.VisibleQuestTypeSource
 import de.westnordost.streetcomplete.databinding.DialogDeleteCacheBinding
 import de.westnordost.streetcomplete.screens.HasTitle
-import de.westnordost.streetcomplete.screens.measure.MeasureActivity
 import de.westnordost.streetcomplete.screens.settings.debug.ShowLinksActivity
 import de.westnordost.streetcomplete.screens.settings.debug.ShowQuestFormsActivity
 import de.westnordost.streetcomplete.util.getSelectedLocales
@@ -116,16 +115,6 @@ class SettingsFragment :
             true
         }
 
-        findPreference<Preference>("debug.ar_measure_horizontal")?.setOnPreferenceClickListener {
-            startActivity(MeasureActivity.createIntent(requireContext(), false))
-            true
-        }
-
-        findPreference<Preference>("debug.ar_measure_vertical")?.setOnPreferenceClickListener {
-            startActivity(MeasureActivity.createIntent(requireContext(), true))
-            true
-        }
-
         buildLanguageSelector()
     }
 
